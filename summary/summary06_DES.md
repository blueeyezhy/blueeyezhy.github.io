# 对称加密(DES)--Python学习总结(六)

> - **PressOne**: [张野](https://press.one/main/p/7c08521960497a61baf3f1c9760ff2a4cc66be1c)
> - [**Mixin**](https://mixin.one/) ID: 21120
> - **Github**: [@blueeyezhy](https://github.com/blueeyezhy)
> - **web**: [blueeyezhy.github.io](https://blueeyezhy.github.io/)

承接上一篇继续用 `python` 实践[《卓克·密码学30讲》](https://m.igetget.com/share/course/pay/detail?id=Enb9L2q1e3OxKBmfPXrgN8P0Rwo6B7)  
为了方便说明做如下设定： 
> A = 信息的发出者；要发出的信息称为**明文**，标识为：**α**  
> B = 信息接收者；  
> C = 信息传递者； 传输过程中的信息称为**密文**，标识为：**β**  
> E = 信息的偷听者；  
>过程：A 将**明文**加密后，通过 C 把**密文**传递给 B ， B 解密获得信息，不让 E 知道**明文**内容。



## 现代密码学--以bit为单位的加密算法时代   
随着计算机的出现，无线电等的发明，传输者C逐渐被光缆，无线电所替代；加密的最小单位从字母，字符变成了字符编码的二进制数字。编码二进制数字打乱了信息的底层结构。将加密与解密的复杂度提升不知道多少个数量级，这之后的密码学叫做现代密码学。  
举个例子：   
```python
coding = "utf-8"
a0 = "btc"
a1 = "btc 1"
a2 = "btc,中"
print("a0=", a0, "\t", len(a0))
print("a1=", a1, "\t", len(a1))
print("a2=", a2, "\t", len(a2))
b0 = "".join([bin(int("1"+hex(i)[2:],16))[3:] for i in a0.encode(coding)])
b1 = "".join([bin(int("1"+hex(i)[2:],16))[3:] for i in a1.encode(coding)])
b2 = "".join([bin(int("1"+hex(i)[2:],16))[3:] for i in a2.encode(coding)])
print("a0=", b0, len(b0), int(b0,2))
print("a1=", b1, len(b1), int(b1,2))
print("a2=", b2, len(b2), int(b2,2))


[OUT:]
a0= btc 	 3
a1= btc 1 	 5
a2= btc,中 	 5
a0= 011000100111010001100011 24 6452323
a1= 0110001001110100011000110010000000110001 40 422859448369
a2= 01100010011101000110001100101100111001001011100010101101 56 27712517021415597
```

如上，`btc` 是一段含有三个英文小写字母的信息，经过 `utf-8` 的编码转换后，变成了24位(8位/英文字符)的二进制数字 `011000100111010001100011` ，相当于十进制的 `6452323` (6百4十5万2千3百2十3)。任何一个字符在 `utf-8` 编码(或者 ``unicode`` 编码下) 都是唯一的。所以只要原文中一点点变化(空格，标点等)，最终得到的二进制数就不同。如 `btc 1` 这5个字符组(空格是一个字符)变成了 `0110001001110100011000110010000000110001` 这个二进制数字。这就使得字符信息与数字一一对应，给现代密码学的加密算法提供了一个全新的世界，进而诞生了第五代加密法(对称加密，代表：DES) 和第六代加密法(非对称加密，代表：RSA)。  

## 第五代加密法--对称加密：**加密与解密共用一个密钥**  
DES加密算法，也称魔王加密法(Lucifer)，通过将明文信息的二进制编码数字的移位，替换，与56位密钥，进行循环异或，编码来实现的。在1979年~1998年之间，作为美国联邦加密标准被广发使用。因为DES的56位密钥，抗大算力暴力破解能力较弱；进入21世纪，AES算法以其优异的抗大算力暴力破解能力，逐渐取代DES的位置，成为对称加密算法的主流。

### DES加密法详解以及代码实现(下方附录为完成代码)  
为了直观说明，我把每一步的输入输出都进行了显示
1. 发出者A 将明文信息 `α` 编码，生成二进制信息列表(其中每个元素为64为二进制数字字符)   
    ```python
    #明文
    α = """姓名: 张野 （男)
    Mixin ID: 21120
    身份证号码: 123456 78901234 5678"""

    #DES加密类参数：需要进行加密的信息
    INFO = α

    #DES加密类参数：密钥
    KEY = "bitcoin4you"

    #DES配置参数，1为加密；0为解密
    if INFO == α:
        OP = 1
    elif INFO == β:
        OP = 0
        
    #实例化DES加密类，并调用str2bin_list函数，将α转化为二进制数列表
    ENCRYPTION = EncryptionDES(INFO, KEY, OP)
    info_bin_list = ENCRYPTION.str2bin_list(INFO)

    #输出二进制数列表及其长度
    for i in info_bin_list:
        print(i, len(i))
    print(len(info_bin_list))

    [OUT]  #明文α转化为14个64位二进制数列表
    0101110001110101001101010011100101100100001100110101110001110101 64
    0011010100110100001100000110010000111010001000000101110001110101 64
    0011010101100110001100100011000001011100011101010011100100110001 64
    0110001101100101001000000101110001110101011001100110011000110000 64
    0011100001011100011101010011011100110101001100110011011100101001 64
    0011101101001101011010010111100001101001011011100010000001001001 64
    0100010000111010001000000011001000110001001100010011001000110000 64
    0011101101011100011101010011100001100101011000010110001001011100 64
    0111010100110100011001010110011001100100010111000111010100111000 64
    0110001001100011001100010101110001110101001101010011001101100110 64
    0011011101011100011101010011011100111000001100000011000100111010 64
    0010000000110001001100100011001100110100001101010011011000100000 64
    0011011100111000001110010011000000110001001100100011001100110100 64
    0010000000110101001101100011011100111000000000000000000000000000 64
    14
    ```
   内部封装
   > 1. 明文α替换换行符，进行`unicode`编码
   > 2. 以64位为单位拆分编码，最后一段不足64位的补0
   > 3. 返回64位二进制明文列表

2. 密钥KEY编码，替代，循环移位生成密钥列表(48位*16个)   
    ```python
    KEY = "bitcoin4you"

    #实例化DES加密类，并调用creat_keys函数，将KEY转化为二进制密钥列表
    ENCRYPTION = EncryptionDES(INFO, KEY, OP)
    key_list = ENCRYPTION.creat_keys(KEY)

    #输出二进制密钥列表及其长度
    for i in key_list:
        print(i, len(i))
    print(len(key_list))

    [OUT]  #密钥KEY转化为16个48位二进制密钥列表
    111100001011111000100110101110000100001001101111 48
    111000001011111001100110011000110100110110100100 48
    111000001111011001110110000010000010100110011111 48
    111001001101011101110010111001110101000010010101 48
    111001101101001101110011010000110000001111101011 48
    101011111101001101010011100101101001100100001101 48
    001011110101001111011011010000100001011111110100 48
    001111110101000111011001010110011010100110101001 48
    000111110101100111011001001001001110011001101101 48
    000111110110100111011001101110101001110011000010 48
    000111110110110110001101100011001100011100110011 48
    010110110010110110001101000111110110111001000000 48
    010110011010110010101101111110001100000101010000 48
    110100011010110010101110100000011110011000001110 48
    111100001010111010100110111111000011011010000000 48
    111100001011111000100110000110111011000000110101 48
    16
    ```
   内部封装
   > 1. 将KEY进行`unicode`编码，获取并替换有效56位密钥
   > 2. 将56位密钥拆分成左(c:28位)右(d:28位)两段
   > 3. c，d向左移k[0]位，然后合并生成56位二进制字符串
   > 4. 将上一步结果压缩，移位替换生成48位子密钥key[0]
   > 5. 循环上面第iii 到 iv 步16次(i=[0~15])，其中移位数k[0,1,8,15]左移1位，其余的左移2位
   > 6. 返回16个48位子密钥列表   
   
3. 循环16次调用f函数，利用子密钥列表，对明文二进制数列表里的每一个元素进行加密，输出密文二进制数列表。
    ```python
    #实例化DES加密类，并调用encryption_des函数，执行加密过程
    ENCRYPTION = EncryptionDES(INFO, KEY, OP)
    cipher = ENCRYPTION.encryption_des()

    #显示二进制密文列表及其长度
    for i in output:
        print(i, len(i))
    print(len(output))

    [OUT]  #生成14个64位二进制密文列表
    0101100001100101001001010010110101110100001000100101100001100101 64
    0010010100100100001000000111010000101111001100000101100001100101 64
    0010010101110111001000110010000001011000011001010010110100100001 64
    0111001001110101001100000101100001100101011101110111011100100000 64
    0010110001011000011001010010011000100101001000100010011000111101 64
    0010111001001001011111010110110001111101011110110011000001001101 64
    0100010000101111001100000010001100100001001000010010001100100000 64
    0010111001011000011001010010110001110101011100010111001101011000 64
    0110010100100100011101010111011101110100010110000110010100101100 64
    0111001101110010001000010101100001100101001001010010001001110111 64
    0010011001011000011001010010011000101100001000000010000100101111 64
    0011000000100001001000110010001000100100001001010010011100110000 64
    0010011000101100001011010010000000100001001000110010001000100100 64
    0011000000100101001001110010011000101100000000000000000000000000 64
    14
    ```
   内部封装
   > 1. 获取一个64位明文二进制数α[0]，进行位置替换，然后分成左(l:32位)右(r:32位)两段
   > 2. 循环调用 **f** 函数16次, 用16个子密钥按照 **0~15** 的顺序，对左(l:32位)右(r:32位)两段数进行加密运算；输出**左**(l_β:32位)**右**(r_β:32位)两段加密信息 **(op==1，加密时)**  
   >> ---     
   >> **f 函数内部封装** 
   >> 1. 将右(r:32位)二进制数赋值给下一轮循环的**左**(l[+1]:32位)
   >> 2. 将右(r:32位)二进制数扩展替换到48位二进制数，生成右(r:48位)
   >> 3. 将右(r:48位)与子密钥key[0]的48位进行异或运算
   >> 4. 将48位异或结果，经s列表编码，压缩成32位二进制数  
   >> 48位二进制数分成8组每组6个，经过s列表编码后生成8组每组4个二进制数，共32位。   
   >> 生成方法：每组6位二进制数对应一个二维s列表，第1，6位组合数字为第1维坐标，第2，3，4，5位组合数字为第2维坐标，根据坐标找到对应的数字，将该数转化为4位二进制数作为输出。  
   >> 例：第i组的6个二进制数字为 `110110` 其对应的二维列表为s[i]；第1位 `1` 与第6位 `0` 组合为 `10` = 2，形成s[i]的第一维坐标x ；第2，3，4，5位是 `1011` = 11，形成s[i]的第二维坐标y，根据s[i]列表找到s[i][x][y]对应的数字，将这个数字二进制化作为4位输出。
   >> 5. 将压缩的32位二进制数，经p列表替换生成二进制数右(r:32位)
   >> 6. 将生成的右(r:32位)二进制数与输入的左(l:32位)二进制数进行异或运算
   >> 7. 将异或结果赋值给**右**(r[+1]:32位)
   >> 8. 输出**左**(l[+1]:32位)和**右**(r[+1]:32位)
   >> 9. 循环调用上述第 i 到 viii 步执行16次，子密钥按照 **0~15** 的顺序调用。
   >> 10. 循环后输出 **左**(l_β:32位) 和 **右**(r_β:32位)
   >> ---
   > 3. 合并**右**(r_β:32位)和**左**(l_β:32位)形成一个新64位二进制密文串
   > 4. 将上一步输出结果，进行位置**逆**替换，生成密文β[0]
   > 5. 循环上面第 i 到 iv 步，直到所有明文二进制数α[i]，全部被加密转化为密文二进制数β[i]
   > 6. 返回密文β二进制信息列表

4. 密文β二进制信息列表，合并解码形成密文β，传输给B   
    ```python
    #实例化DES加密类，并调用encryption_des函数，执行加密过程,输出解密结果及长度
    ENCRYPTION = EncryptionDES(INFO, KEY, OP)
    cipher = ENCRYPTION.encryption_des()
    print(cipher, len(cipher))

    [OUT]  #生成14个64位二进制密文列表
    Xe%-t"Xe%$ t/0Xe%w# Xe-!ru0Xeww ,Xe&%"&=.I}l}{0MD/0#!!# .Xe,uqsXe$uwtXe,sr!Xe%"w&Xe&, !/0!#"$%'0&,- !#"$0%'&, 
    112
    ```
   内部封装
   > 1. 密文β二进制信息列表，合并成一个二进制字符串
   > 2. 进行`unicode`解码，形成密文β
   
   `Xe%-t"Xe%$ t/0Xe%w# Xe-!ru0Xeww ,Xe&%"&=.I}l}{0MD/0#!!# .Xe,uqsXe$uwtXe,sr!Xe%"w&Xe&, !/0!#"$%'0&,- !#"$0%'&,` 这个112个字节长度的字符串就是密文β，在不知道密钥的情况下，没有办法反向解析出明文α。

5. B接受到密文β，使用事先约定好的KEY，对密文β进行解密生成原文α 
    ```python
    #密文
    β = '''Xe%-t"Xe%$ t/0Xe%w# Xe-!ru0Xeww ,Xe&%"&=.I}l}{0MD/0#!!# .Xe,uqsXe$uwtXe,sr!Xe%"w&Xe&, !/0!#"$%'0&,- !#"$0%'&,'''
  
    #DES加密类参数：需要进行解密的信息
    INFO = β

    #DES加密类参数：密钥
    KEY = "bitcoin4you"

    #DES配置参数，1为加密；0为解密
    if INFO == α:
        OP = 1
    elif INFO == β:
        OP = 0
        
    #实例化DES加密类，并调用encryption_des()函数，在OP==0，下运行输出明文α
    ENCRYPTION = EncryptionDES(INFO, KEY, OP)
    info = ENCRYPTION.encryption_des()
    print(info, '\n', len(info))

    [OUT]  #输出明文α
    姓名: 张野 （男)
    Mixin ID: 21120
    身份证号码: 123456 78901234 5678 
    54
    ``` 
   解密过程和加密过程绝大多数都是相同的，唯一区别是子密钥的使用顺序，和最后输出时去除补充的空字符以及换行符替换。 中间过程我略掉，直接输出结果。   
   内部封装
   > 1. 密文β进行`unicode`编码，拆分成长64bit的二进制数列表
   > 2. 密钥KEY编码，替代，循环移位生成密钥列表(48位*16个)
   > 3. 循环16次调用f函数，利用子密钥列表，对密文二进制数列表里的每一个元素进行解密，输出明文二进制数列表。**注意**：解密时子密钥的使用顺序为**15~0**。
   > 4. 明文二进制信息列表，合并，解码，剔除末位`None`字符，替换回换行符，形成明文α

经过上述5个步骤，A将明文信息内容通过加密，密文传输，解密最终传递给了B。这个过程中，E即使在密文传递过程中，获取了密文，在没有密钥的情况下，也很难获取明文内容(除非大算力暴力破解56位密钥)，从而保证了信息主体的安全。但是，一旦密钥在传递过程中泄露被E获知，那么A，B之间所有通信内容将全部暴露。这也是DES加密法最大的漏洞，上世纪70年代，保密等级要严格的场合，专门有个职位，每天提着保险箱飞到全球各地给客户送密钥。  

那么这个问题能否解决呢？  
那就要等到第六代密码系统--非对称加密系统的诞生了。

## 实践中的问题与成长点   
1. 信息在编码数字化时，首位的`0`会默认去掉。例如字符`b`，转化成二进制数时会变成`1100010`7位。这样在存英文环境中，解码不会有问题；但是在世界语言(中文，日文，韩文等)环境中，会出现解码错误。所以需要补全8位(`b`=`01100010`)，并用`unicode`进行编码解码。   
另外，`unicode`和`utf-8`编码，对于英文数字以外的字符编码是不同的，在转换过程中需要特别注意。这些内容[李俊老师的支线课程](https://www.bilibili.com/video/av75561581?from=search&seid=201132862313217459)有说明，大家可以去学习。

2. 当今，数据的传输都是以电信号或者光信号传输的，信息传输的基本单位是8位二进制数(1个byte)。为了提升传输效率，尽量使用少的数据表达多的内容。比如说，英文表达中每一个英文字符只需要1个字节就可以标识；而其他字符，比如中文，一个字符就需要3个字节(`utf=8`)或者6个字节(`unicode`)来标识，所以相对一个字符的传递显然英文更有效率。因此在需要进行信息传递的场合，需要酌情选择。

3. 通过这个实践，使我对于信息数字化，加密解密有了更深一层理解；同时对于python字符串的操作，类的创建以及使用能力有了质的提高。

## 后续持续实践
* 第六代加密法--RSA加密系统
* 第七代加密法--量子加密
* AES加密法(对称加密)
* EI Gamal算法(非对称加密)

---
> [python学习总结(五)--Encryption and decryption-1](https://read.firesbox.com/posts/88f057fa93c7f831e36014cd7b4538474c9f8ce4cb495cfd2535524c0ecbf033)    
> [python学习总结(四)--String parsing](https://read.firesbox.com/posts/7b71ead909c1b46fc5ac914e70d9d744a5bb019cf99757e28fcfc273d59c4671)   
> [python学习总结(三)--PyQt](https://read.firesbox.com/posts/d7b80845d7870c33960dc349b6b1765c4145e4afac3aac00f422b713ca8fa320)   
> [python学习总结(二)--Powershell](https://read.firesbox.com/posts/ffc76fa8634a3be98e4f7ca9e45d7b5b33a41a3f5374a8153eaa42daddd91997)  
> [python学习总结(一)](https://read.firesbox.com/posts/b4ebbc69f1e5e4ba1069f112dcfef65fd7238bce3c7a722fae78e0fb6976fe5c)  
---
**定投践行社区**里面有李俊老师的**Python编程课**，刘晓艳老师的**英文课**(正在讲的是《**beyond feelings**》)，廖智小姐姐的幸福力(**汶川地震30小时深埋地下的感悟**)，老虎证券王珊老师的**读财报课**，还有李笑来老师的**写作课**和**定投课**，**定投时间**超值体验如果你也想加入，注册 [**Mixin**](https://mixin.one/) 加我(ID: **21120**)好友，送你邀请码。

**注:** 践行社区是建立在 [**Mixin Massager**](https://mp.weixin.qq.com/s/ci_OWj9vtnsJ4OROifNfSQ) 上的社群，所以你必须学会使用 Mixin  Massager ；同时践行社区是封闭课程社区没有邀请码不能加入。)

---
### 附: DES加密完整代码：  
``` python
"""
DES by Python
"""
from bitarray import bitarray

class EncryptionDES():
    """
    class of DES
    """
    def __init__(self, info, key, op):
        self.op = op
        self.info_list = self.str2bin_list(info)
        self.key_list = self.creat_keys(key)
        self.s_list = self.creat_s_list()


    def creat_s_list(self):
        """
        生成f函数所需的三维数组压缩列表，8*4*16
        """
        #s1压缩列表
        s1 = [[14,  4, 13,  1,  2, 15, 11,  8,  3, 10,  6, 12,  5,  9,  0,  7],
              [ 0, 15,  7,  4, 14,  2, 13,  1, 10,  6, 12, 11,  9,  5,  3,  8],
              [ 4,  1, 14,  8, 13,  6,  2, 11, 15, 12,  9,  7,  3, 10,  5,  0],
              [15, 12,  8,  2,  4,  9,  1,  7,  5, 11,  3, 14, 10,  0,  6, 13]]
        #s2压缩列表
        s2 = [[15,  1,  8, 14,  6, 11,  3,  4,  9,  7,  2, 13, 12,  0,  5, 10],
              [ 3, 13,  4,  7, 15,  2,  8, 14, 12,  0,  1, 10,  6,  9, 11,  5],
              [ 0, 14,  7, 11, 10,  4, 13,  1,  5,  8, 12,  6,  9,  3,  2, 15],
              [13,  8, 10,  1,  3, 15,  4,  2, 11,  6,  7, 12,  0,  5, 14,  9]]
        #s3压缩列表
        s3 = [[10,  0,  9, 14,  6,  3, 15,  5,  1, 13, 12,  7, 11,  4,  2,  8],
              [13,  7,  0,  9,  3,  4,  6, 10,  2,  8,  5, 14, 12, 11, 15,  1],
              [13,  6,  4,  9,  8, 15,  3,  0, 11,  1,  2, 12,  5, 10, 14,  7],
              [ 1, 10, 13,  0,  6,  9,  8,  7,  4, 15, 14,  3, 11,  5,  2, 12]]
        #s4压缩列表
        s4 = [[ 7, 13, 14,  3,  0,  6,  9, 10,  1,  2,  8,  5, 11, 12,  4, 15],
              [13,  8, 11,  5,  6, 15,  0,  3,  4,  7,  2, 12,  1, 10, 14,  9],
              [10,  6,  9,  0, 12, 11,  7, 13, 15,  1,  3, 14,  5,  2,  8,  4],
              [ 3, 15,  0,  6, 10,  1, 13,  8,  9,  4,  5, 11, 12,  7,  2, 14]]
        #s5压缩列表
        s5 = [[ 2, 12,  4,  1,  7, 10, 11,  6,  8,  5,  3, 15, 13,  0, 14,  9],
              [14, 11,  2, 12,  4,  7, 13,  1,  5,  0, 15, 10,  3,  9,  8,  6],
              [ 4,  2,  1, 11, 10, 13,  7,  8, 15,  9, 12,  5,  6,  3,  0, 14],
              [11,  8, 12,  7,  1, 14,  2, 13,  6, 15,  0,  9, 10,  4,  5,  3]]
        #s6压缩列表
        s6 = [[12,  1, 10, 15,  9,  2,  6,  8,  0, 13,  3,  4, 14,  7,  5, 11],
              [10, 15,  4,  2,  7, 12,  9,  5,  6,  1, 13, 14,  0, 11,  3,  8],
              [ 9, 14, 15,  5,  2,  8, 12,  3,  7,  0,  4, 10,  1, 13, 11,  6],
              [ 4,  3,  2, 12,  9,  5, 15, 10, 11, 14,  1,  7,  6,  0,  8, 13]]
        #s7压缩列表
        s7 = [[ 4, 11,  2, 14, 15,  0,  8, 13,  3, 12,  9,  7,  5, 10,  6,  1],
              [13,  0, 11,  7,  4,  9,  1, 10, 14,  3,  5, 12,  2, 15,  8,  6],
              [ 1,  4, 11, 13, 12,  3,  7, 14, 10, 15,  6,  8,  0,  5,  9,  2],
              [ 6, 11, 13,  8,  1,  4, 10,  7,  9,  5,  0, 15, 14,  2,  3, 12]]
        #s8压缩列表
        s8 = [[13,  2,  8,  4,  6, 15, 11,  1, 10,  9,  3, 14,  5,  0, 12,  7],
              [ 1, 15, 13,  8, 10,  3,  7,  4, 12,  5,  6, 11,  0, 14,  9,  2],
              [ 7, 11,  4,  1,  9, 12, 14,  2,  0,  6, 10, 13, 15,  3,  5,  8],
              [ 2,  1, 14,  7,  4, 10,  8, 13, 15, 12,  9,  0,  3,  5,  6, 11]]
        return [s1, s2, s3, s4, s5, s6, s7, s8]


    def str2bin_list(self, info):
        """
        Convert the info into bin_list, the lenth of each item is 64 bit.
        """
        info = info.replace("\n",";")
        info_bin_list = []
        info_bin_str = "".join([bin(int("1"+hex(i)[2:],16))[3:] for i in info.encode("unicode_escape")])
        k = len(info_bin_str)//64
        mod = len(info_bin_str)%64
        if mod == 0:
            n = k
            info_bin_added = info_bin_str
        else:
            n = k+1
            info_bin_added = info_bin_str+"0"*(64-mod)
        for i in range(n):
            info_bin_list.append(info_bin_added[i*64:(i+1)*64])
        return info_bin_list


    def bin_list2str(self, info_bin_list):
        """
        Convert bin_list into info, which is going to be sended, or read if decryption.
        """
        info_str = "".join(info_bin_list)

        if self.op == 1:
            info_out = bitarray(info_str).tobytes().decode("unicode_escape")
        elif self.op == 0:
            info_out = bitarray(info_str).tobytes().decode("unicode_escape").strip("\x00").replace(";","\n")
        return info_out


    def creat_keys(self, key):
        """
        Creat keys list from key input.
        """
        #密钥的替换位置列表1，将64位的密钥转换为56位
        id_list_1 = [ 57, 49, 41, 33, 25, 17,  9,  1, 58, 50, 42, 34, 26, 18,
                      10,  2, 59, 51, 43, 35, 27, 19, 11,  3, 60, 52, 44, 36,
                      63, 55, 47, 39, 31, 23, 15,  7, 62, 54, 46, 38, 30, 22,
                      14,  6, 61, 53, 45, 37, 29, 21, 13,  5, 28, 20, 12,  4 ]
        #子密钥的替换位置列表2，将56位的密钥转换为48位
        id_list_2 = [ 14, 17, 11, 24,  1,  5,  3, 28, 15,  6, 21, 10,
                      23, 19, 12,  4, 26,  8, 16,  7, 27, 20, 13,  2,
                      41, 52, 31, 37, 47, 55, 30, 40, 51, 45, 33, 48,
                      44, 49, 39, 56, 34, 53, 46, 42, 50, 36, 29, 32 ]
        keys = []
        tmp = "".join([bin(int("1"+hex(i)[2:],16))[3:] for i in (key+"\x00"*64).encode("unicode_escape")])[:64]
        key0 = "".join([tmp[i-1] for i in id_list_1])
        c = key0[:28]
        d = key0[28:]

        for i in range(16):
            if i==0 or i==1 or i==8 or i==15:
                c = c[1:]+c[:1]
                d = d[1:]+d[:1]
            else:
                c = c[2:]+c[:2]
                d = d[2:]+d[:2]
            tmp = c+d
            keys.append("".join([tmp[i-1] for i in id_list_2]))
        return keys


    def f_func(self, l, r, key):
        """
        f-function encryption with keys.
        """
        #扩展替换位置列表，将32bit数据扩展为48bit
        extend_id_list = [ 32,  1,  2,  3,  4,  5,
                            4,  5,  6,  7,  8,  9,
                            8,  9, 10, 11, 12, 13,
                           12, 13, 14, 15, 16, 17,
                           16, 17, 18, 19, 20, 21,
                           20, 21, 22, 23, 24, 25,
                           24, 25, 26, 27, 28, 29,
                           28, 29, 30, 31, 32,  1 ]

        p_id_list = [16,  7, 20, 21, 29, 12, 28, 17,  1, 15, 23, 26,  5, 18, 31, 10,
                      2,  8, 24, 14, 32, 27,  3,  9, 19, 13, 30,  6, 22, 11,  4, 25]
        #赋值l输出
        l_out = r

        #32位r,扩展到48位
        r_ex = [r[i-1] for i in extend_id_list]

        #48位扩展r,与48位key进行异或运算
        res_48 = []
        for i in range(len(r_ex)):
            res_48.append(str(int(r_ex[i])^int(key[i])))

        #异或运算48位结果，进行s列表变换，生成32位结果
        res_32 = []
        for i in range(8):
            x = int(res_48[6*i]+res_48[6*i+5],2)
            y = int("".join(res_48[6*i+1:6*i+5]),2)
            res_32.append("0"*(4-len(bin(self.s_list[i][x][y])[2:]))+bin(self.s_list[i][x][y])[2:])
        res_32_str = "".join(res_32)
        
        #32位结果进行p_list替换，再与l值进行异或运算，生成32位r_out值
        r_p = [res_32_str[i-1] for i in p_id_list]
        tmp = []
        for i in range(len(r_p)):
            tmp.append(str((int(r[i])^int(l[i]))))
        r_out = "".join(tmp)
        
        return l_out, r_out


    def encryption_des(self):
        """
        encryption
        """
        #64位信息info的位置替换列表
        ip_list = [ 58, 50, 42, 34, 26, 18, 10, 2, 
                    60, 52, 44, 36, 28, 20, 12, 4,
                    62, 54, 46, 38, 30, 22, 14, 6, 
                    64, 56, 48, 40, 32, 24, 16, 8,
                    57, 49, 41, 33, 25, 17,  9, 1, 
                    59, 51, 43, 35, 27, 19, 11, 3,
                    61, 53, 45, 37, 29, 21, 13, 5, 
                    63, 55, 47, 39, 31, 23, 15, 7 ]
        #逆64位信息info的位置替换列表
        inv_ip_list = [ 40,  8, 48, 16, 56, 24, 64, 32,
                        39,  7, 47, 15, 55, 23, 63, 31,
                        38,  6, 46, 14, 54, 22, 62, 30,
                        37,  5, 45, 13, 53, 21, 61, 29,
                        36,  4, 44, 12, 52, 20, 60, 28,
                        35,  3, 43, 11, 51, 19, 59, 27,
                        34,  2, 42, 10, 50, 18, 58, 26,
                        33,  1, 41,  9, 49, 17, 57, 25 ]
        output=[]
        for info in self.info_list:
            #64位信息info的位置替换 (ip_list)
            info_ip = "".join([info[i-1] for i in ip_list])
            info_l = info_ip[:32]
            info_r = info_ip[32:]
            
            #执行f_func函数循环调用左右信息和密钥16次，然后调换左右结果, op==0时逆用密钥进行解密
            for i in range(16):
                if self.op == 1:
                    j=i
                elif self.op == 0:
                    j=15-i
                info_l, info_r = self.f_func(info_l, info_r, self.key_list[j])
            tmp = info_r + info_l
           
            #64位信息info的位置 逆替换 (inv_ip_list)后，存入输出列表。
            output.append("".join([tmp[i-1] for i in inv_ip_list]))
        
        #链接所有输出形成密文。
        cipher = self.bin_list2str(output)
        return cipher


if __name__ == "__main__":
    α = """姓名: 张野 （男)
        Mixin ID: 21120
        身份证号码: 123456 78901234 5678"""
    β = '''Xe%-t"Xe%$ t/0Xe%w# Xe-!ru0Xeww ,Xe&%"&=.I}l}{0MD/0#!!# .Xe,uqsXe$uwtXe,sr!Xe%"w&Xe&, !/0!#"$%'0&,- !#"$0%'&,'''
    #INFO = α
    INFO = β
    KEY = "bitcoin4you"
    if INFO == α:
        OP = 1
    elif INFO == β:
        OP = 0

    ENCRYPTION = EncryptionDES(INFO, KEY, OP)
    print(ENCRYPTION.encryption_des())
```